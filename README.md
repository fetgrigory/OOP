# OOP
Данный репозиторий создан для изучения объектно-ориентированного программирования в python
# class_computer.py
Модуль class_computer.py Данный модуль демонстрирует применение основных принципов объектно-ориентированного программирования (ООП) при работе с базой данных SQLite.

Ключевые аспекты ООП, которые модуль демонстрирует:

1. Класс `Computer`: В этом классе определены характеристики и методы, относящиеся к компьютеру. Атрибуты `cpu`, `ram`, `hdd` и `hdd_type` представляют информацию о процессоре, оперативной памяти, жестком диске и его типе, соответственно. Также имеется атрибут `conn`, который представляет соединение с базой данных SQLite.

2. Метод `__init__(self)`: Этот метод выполняется при создании экземпляра класса `Computer`. Он инициализирует атрибуты класса и устанавливает соединение с базой данных.

3. Метод `create_table(self)`: Этот метод создает таблицу "computers" в базе данных SQLite, если она ещё не существует. Он использует SQL-запрос для создания таблицы с необходимыми столбцами.

4. Метод `get_user_input(self)`: Этот метод позволяет пользователю вводить информацию о компьютере, такую как модель процессора, объем оперативной памяти, объем жесткого диска и тип жесткого диска. Он использует словарь `cpu_options` для предоставления пользователю вариантов моделей процессоров и обрабатывает пользовательский ввод.

5. Метод `is_input_correct(self)`: Этот метод проверяет, все ли необходимые атрибуты класса `Computer` были заполнены. Если хотя бы один из них отсутствует, метод возвращает `False`, иначе `True`.

6. Метод `save_to_database(self)`: Этот метод выполняет сохранение информации о компьютере в базу данных. Он использует SQL-запрос `INSERT INTO` для добавления данных в таблицу "computers". Переданные данные вставляются в запрос через параметры, чтобы предотвратить SQL-инъекции.

Использование этого модуля позволяет пользователям вводить информацию о компьютере и сохранять ее в базе данных SQLite. Модуль демонстрирует принцип инкапсуляции. Класс Computer инкапсулирует данные компьютера (cpu, ram, hdd, hdd_type) и методы работы с ними (create_table, get_user_input, is_input_correct, save_to_database). Это означает, что данные и методы класса Computer скрыты от прямого доступа извне, и взаимодействие с ними происходит через публичный интерфейс класса (методы get_user_input и save_to_database), что способствует защите и контролю над данными.
# single_inheritance.py
Модуль single_inheritance.py. Данный модуль демонстрирует применение одиночного наследование классов в ООП. Класс UnitConverter наследует от класса Converter, что позволяет расширить функциональность базового класса. В данном случае, UnitConverter добавляет метод convert() для выполнения конверсии единиц измерения. Одиночное наследование классов означает, что класс может наследовать только от одного базового класса.
# multiple_inheritance.py
Модуль multiple_inheritance.py. Данный модуль демонстрирует множественного наследования классов в ООП. Код программы представляет собой реализацию игры "Крестики-нолики" с использованием объектно-ориентированного программирования (ООП). Основная идея игры - заполнить игровое поле 3x3 крестиками или ноликами в определенной комбинации, чтобы победить противника.

 Множественное наследование позволяет классу наследовать свойства и методы нескольких родительских классов. В данном случае класс `TicTacToe` наследуется от классов `Board`, `Player` и `AI`, чтобы получить функциональность игрового поля, игрока и искусственного интеллекта соответственно.

Класс `Board` представляет игровое поле. Он имеет конструктор, который создает список с 9 элементами, представляющими ячейки игрового поля. Метод `print_board` используется для вывода текущего состояния игрового поля на экран. Методы `is_board_full` и `is_winner` проверяют, заполнено ли игровое поле полностью и есть ли победитель соответственно.

Класс `Player` представляет игрока. Он инициализируется символом (крестиком или ноликом), которым игрок будет играть. Метод `make_move` запрашивает у игрока ввод номера ячейки, в которую он хочет сделать ход, и проверяет, является ли ячейка пустой. Если ячейка свободна, игрок делает ход, изменяя состояние игрового поля. В противном случае выводится сообщение об ошибке.

Класс `AI` представляет искусственный интеллект. Он также инициализируется символом, которым будет играть. Метод `make_move` генерирует случайное число, представляющее позицию свободной ячейки на игровом поле, и делает ход за искусственного интеллекта, изменяя состояние игрового поля.

Класс `TicTacToe` объединяет все компоненты игры. Он наследует функциональность классов `Board`, `Player` и `AI`. В конструкторе `TicTacToe` вызывается конструктор родительского класса `Board`, чтобы создать игровое поле. У `TicTacToe` также есть переменная `current_player`, которая указывает на текущего игрока.

В основной части программы создается объект `TicTacToe` и игра начинается. Игроки и искусственный интеллект поочередно совершают ходы, пока игра не закончится. По результатам ходов определяется победитель или ничья. Соответствующие сообщения выводятся на экран.

Таким образом, множественное наследование классов в данном коде позволяет легко объединить различные компоненты игры и расширить функциональность объекта `TicTacToe` за счет наследования свойств и методов от нескольких родительских классов.

# multilevel_inheritance.py
Модуль multilevel_inheritance.py. Данный модуль демонстрирует многоуровневое наследование классов. В представленном коде  коде программы есть пример многоуровневого наследования классов. Класс MultiLevelGame является подклассом класса Game, который в свою очередь является подклассом класса object.

Класс Game представляет собой игру с несколькими игроками. Он содержит методы для игры, включая метод play_game, который запускает игру, и метод print_scores, который выводит на экран текущие счета игроков.

Класс MultiLevelGame расширяет функциональность класса Game, добавляя возможность указания уровня игры. Метод play_game в классе MultiLevelGame переопределяет метод play_game из класса Game, чтобы добавить вывод информации о текущем уровне игры перед игрой и после её завершения.

Другие классы в коде включают класс Dice, который представляет собой кубик с заданным количеством граней и содержит метод roll для броска кубика. Есть также класс Player, представляющий игрока с именем и счетом, и методом play_turn, который имитирует ход игрока.

Программа создает двух игроков, player1 и player2, и создает объект класса Game, передавая этим игрокам в качестве аргумента. Затем программа запускает игру методом play_game и выводит текущие счета игроков методом print_scores.

Таким образом, многоуровневое наследование классов в коде позволяет наследовать и переопределять методы и атрибуты из разных уровней иерархии классов, что способствует модульности и переиспользованию кода.
# hierarchical_inheritance.py
Модуль hierarchical_inheritance.py. Данный код представляет собой простую игру викторина, реализованную с использованием иерархического наследования классов в объектно-ориентированном программировании.

Иерархическое наследование классов предполагает наличие главного класса (в данном случае класса `Question`), от которого наследуются другие классы (в данном случае классы `Game`). Класс `Game` расширяет (наследует) функциональность класса `Question`, добавляя дополнительные методы и поля для организации игрового процесса.

Класс `Question` представляет собой модель вопроса, содержащую текст вопроса (`question`), варианты ответа (`options`) и номер правильного ответа (`answer`). Класс имеет метод `display_question`, который выводит вопрос и варианты ответа на экран, и метод `check_answer`, который проверяет, совпадает ли ответ пользователя с правильным ответом.

Класс `Game` представляет собой модель игры, содержащую список вопросов (`questions`) и счет (`score`). Он имеет методы `start` и `end_game`. Метод `start` запускает игру, перемешивая вопросы в случайном порядке, выводит вопросы на экран, принимает ответы пользователя и проверяет их. Если ответ правильный, счет увеличивается. В конце игры метод `end_game` выводит окончательный счет.

Основная логика игры располагается в методе `start` класса `Game`. Она проходит по всем вопросам и в цикле выводит на экран каждый вопрос. Затем пользователь вводит свой ответ, который проверяется методом `check_answer`. В зависимости от результата проверки выводится соответствующее сообщение о правильности ответа, и счет обновляется. После завершения цикла игра выводит окончательный счет.

Таким образом, в данной программе иерархическое наследование классов используется для организации связи между общим классом `Question` и более конкретным классом `Game`, позволяя создать функциональность игры на основе модели вопросов.
# hybrid_inheritance.py
Модуль hybrid_inheritance.py. Код представляет собой реализацию игры "Поле чудес" с использованием гибридного наследования классов в объектно-ориентированном программировании.

Гибридное наследование - это комбинация нескольких видов наследования одновременно, в данном случае класс `Game` наследует функциональность классов `HangmanGame` и `Player`.

Класс `Player` представляет игрока и имеет одно свойство `name`, которое хранит имя игрока. 

Класс `HangmanGame` представляет собой основную логику игры "Виселица". У него есть свойства `word`, которое хранит загаданное слово, и `guessed_letters`, которое содержит список угаданных букв. Класс также содержит три метода:

- `display_word()`, который отображает текущее состояние угадываемого слова. Если буква уже отгадана, она отображается, иначе вместо нее ставится символ подчеркивания.
- `guess_letter(letter)`, который добавляет угаданную букву в список `guessed_letters`.
- `check_win()`, который проверяет, все ли буквы загаданного слова были угаданы. Если да, возвращает `True`, иначе - `False`.

Класс `Game` наследует функциональность классов `HangmanGame` и `Player`. В его конструкторе вызываются конструкторы обоих родительских классов с передачей соответствующих аргументов. Класс также содержит метод `start_game()`, который запускает игру. 

Внутри цикла `while` происходит основной игровой процесс. Игроку выводится вопрос "Which programming language uses the .py file extension?" и текущее состояние угадываемого слова. Затем игроку предлагается угадать букву, которая добавляется в список `guessed_letters` с помощью метода `guess_letter()`. Цикл продолжается, пока не будут угаданы все буквы и метод `check_win()` не вернет `True`.

По завершении игры выводятся поздравления с победой, имя игрока и загаданное слово.

Таким образом, гибридное наследование позволяет классу `Game` наследовать функциональность и состояние и от класса `HangmanGame`, и от класса `Player`. Это позволяет использовать их методы и свойства в контексте игрового процесса и хранить информацию о текущем игроке.
# decorators.py
Модуль decorators.py. В данном коде используется декоратор limit_attempts, который ограничивает количество попыток отгадывания загадки (max_attempts). Декоратор применен к функции guess_riddle.

Декоратор limit_attempts принимает аргумент max_attempts, который задает максимальное количество попыток.

Затем он возвращает внутренний декоратор decorator, который в свою очередь применяется к функции guess_riddle.

Внутренний декоратор decorator определяет новую функцию-обертку wrapper. Внутри wrapper есть цикл, который выполняется до тех пор, пока не останутся доступные попытки. Каждая попытка увеличивает счетчик attempts.

В теле wrapper вызывается исходная функция func, которая принимает все переданные ей аргументы. В нашем случае func соответствует функции guess_riddle(). Затем проверяется результат отгадывания (result).

Если отгадывание успешно, функция возвращает True и игра завершается с поздравлением. Если ответ неверный, печатается сообщение о неправильном ответе и цикл продолжается до истечения попыток.

Если достигнут лимит попыток, печатается сообщение об исчерпании попыток и функция возвращает False.

Декоратор functools.wraps применяется для сохранения информации о исходной функции guess_riddle внутри wrapper. Это важно для сохранения имени функции и других атрибутов в декорированной функции.
# patterns.py
Приведенный код представляет собой простую игру "камень-ножницы-бумага" с использованием паттернов программирования Singleton (Одиночка) и Factory (Фабрика).

В начале кода определяется класс "Game", который содержит логику игры. У него есть методы "get_computer_choice" и "get_user_choice", которые вызываются для получения выбора компьютера и пользователя соответственно. Метод "play" запускает игру, получая выбор пользователя и компьютера, а затем выводит результат игры.

Далее следует паттерн Singleton (Одиночка) для класса "GameManagerSingleton". Одиночка гарантирует, что в системе существует только один экземпляр класса. В данном случае, класс "GameManagerSingleton" содержит экземпляр игры, созданный с помощью класса "Game". У класса есть статический метод "get_instance()", который возвращает этот экземпляр. Если экземпляр не существует, он создается при первом вызове этого метода.

Затем идет паттерн Factory (Фабрика) для класса "GameFactory". Фабрика предоставляет интерфейс для создания объектов определенного типа без указания конкретного класса. В данном случае, класс "GameFactory" имеет метод "create_game()", который создает экземпляр игры, используя метод "get_instance()" класса "GameManagerSingleton".

В конце кода создается экземпляр класса "GameFactory" с помощью переменной "game_factory". Затем вызывается метод "create_game()", который создает и запускает игру.

Таким образом, паттерн Singleton позволяет гарантировать, что в системе существует только один экземпляр игры, а паттерн Factory обеспечивает гибкость создания экземпляров игры без привязки к конкретному классу, что упрощает добавление новых типов игр в систему.

Все эти паттерны программирования на Python позволяют улучшить структуру кода, сделать его более гибким и легко расширяемым.
Factory обеспечивает гибкость создания объектов без привязки к конкретным классам. Если в будущем мы захотим добавить новую игру, мы сможем легко расширить класс GameFactory, не изменяя существующий код.

Таким образом, создана игра "Камень, ножницы, бумага" на Python и использованы паттерны Singleton и Factory для достижения гибкости и управления процессами создания игры.
